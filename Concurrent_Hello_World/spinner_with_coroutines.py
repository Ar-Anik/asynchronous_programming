"""
# OS Scheduler vs. Event Loop
সাধারণত অপারেটিং সিস্টেমের শিডিউলার থ্রেড এবং প্রসেসগুলোকে সিপিইউ টাইম বরাদ্দ করে চালায়। কিন্তু কোরুটিনের ক্ষেত্রে বিষয়টি আলাদা। কোরুটিনগুলো
পরিচালিত হয় একটি Application-level Event Loop-এর মাধ্যমে।
- এই ইভেন্ট লুপটি pending কোরুটিনগুলোর একটি Queue পরিচালনা করে এবং একে একে সেগুলো চালায়।
- এটি I/O অপারেশনের ইভেন্টগুলো মনিটর করে এবং কাজ শেষ হলে সংশ্লিষ্ট কোরুটিনকে আবার নিয়ন্ত্রণ ফিরিয়ে দেয়।
- সবচেয়ে গুরুত্বপূর্ণ বিষয় হলো—ইভেন্ট লুপ, লাইব্রেরি কোরুটিন এবং ইউজার কোরুটিন সব একটি মাত্র সিঙ্গেল থ্রেডে (Single Thread) চলে। তাই কোনো
একটি কোরুটিন যদি বেশি সময় ব্যয় করে বা আটকে যায় তবে পুরো ইভেন্ট লুপ এবং অন্যান্য সব কোরুটিনও থেমে যায়।
"""

import asyncio
import itertools
import time

async def spin(msg: str):
    for char in itertools.cycle(r'\|/-'):
        status = f'\r{char} {msg}'
        print(status, flush=True, end='')

        try:
            await asyncio.sleep(.1)
        except asyncio.CancelledError:
            break

    blanks = ' ' * len(status)
    print(f'\r{blanks}\r', end='')


async def slow_1():
    await asyncio.sleep(3)
    return 69

async def slow_2():
    time.sleep(3)
    return 106

async def supervisor():
    spinner = asyncio.create_task(spin('thinking!'))
    print(f'Spinner Object: {spinner}')

    result = await slow_1()

    spinner.cancel()

    return result


def main():
    result = asyncio.run(supervisor())
    print(f'Answer : {result}')


if __name__ == '__main__':
    main()

"""
1. main() function : এটি প্রোগ্রামের একমাত্র সাধারণ ফাংশন। এটি asyncio.run() ব্যবহার করে main entry point হিসেবে কাজ করে। 

2. asyncio.run(supervisor()): এটি event loop শুরু করে। যতক্ষণ পর্যন্ত supervisor coroutine-টি শেষ না হয়, ততক্ষণ main ফাংশনটি কাজ 
বন্ধ করে অপেক্ষা করে। 

3. Native Coroutine: Coroutine তৈরি করার জন্য async def ব্যবহার করা হয়। 

4. asyncio.create_task(): এটি একটি coroutine-কে ভবিষ্যতে চালানোর জন্য শিডিউল করে। এটি সাথে সাথেই একটি Task object return করে 
এবং বর্তমান code চালানো বন্ধ করে না। 

5. await slow(): এখানে await ব্যবহার করার মানে হলো, যতক্ষণ slow() coroutine-টি ফলাফল না দিচ্ছে, ততক্ষণ supervisor coroutine-টি 
স্থগিত থাকবে। 

6. spinner.cancel(): কাজ শেষে এই মেথডটি স্পিনার কোরুটিনের ভেতরে একটি CancelledError তৈরি করে সেটি বন্ধ করে দেয়।
"""

"""
# Coroutine চালানোর তিনটি প্রধান উপায়
1. asyncio.run(coro()): এটি একটি সাধারণ ফাংশন থেকে কল করা হয়। এটি event loop শুরু করে এবং coroutine-টি শেষ না হওয়া পর্যন্ত অপেক্ষা 
করে। সাধারণত এটি প্রোগ্রামের এন্ট্রি পয়েন্ট হিসেবে ব্যবহৃত হয়।

2. asyncio.create_task(coro()): এটি একটি কোরুটিনের ভেতর থেকে অন্য একটি কোরুটিনকে শিডিউল করতে ব্যবহৃত হয়। এটি বর্তমান কোরুটিনকে 
থামায় না বরং একটি Task object return করে যা দিয়ে ওই Task টি নিয়ন্ত্রণ করা যায়।

3. await coro(): এটি একটি coroutine থেকে অন্য একটি কোরুটিনে নিয়ন্ত্রণ হস্তান্তর করে। এর ফলে বর্তমান কোরুটিনটি সাময়িকভাবে স্থগিত হয় যতক্ষণ 
না কল করা কোরুটিনটি তার কাজ শেষ করে।

Note : কোনো কোরুটিনকে শুধু coro() হিসেবে কল করলে সেটি একটি কোরুটিন অবজেক্ট রিটার্ন করে কিন্তু কোডটি চালায় না। কোড চালানোর দায়িত্ব হলো ইভেন্ট লুপের।
"""

"""
যদি slow কোরুটিনে await asyncio.sleep(3) এর জায়গায় পাইথনের সাধারণ ব্লকিং ফাংশন time.sleep(3) ব্যবহার করা হয় then ফলাফল যা দেখা যাবে : 
- স্পিনার অবজেক্টটি প্রদর্শিত হবে। 
- কিন্তু কোনো স্পিনার অ্যানিমেশন দেখা যাবে না। প্রোগ্রামটি 3 সেকেন্ডের জন্য পুরোপুরি হ্যাং বা আটকে থাকবে। 
- 3 সেকেন্ড পর সরাসরি "Answer: 69" দেখাবে এবং প্রোগ্রাম শেষ হবে।

Q : কেন এটি ঘটে?
-> যেহেতু পুরো প্রোগ্রামটি একটি মাত্র মেইন থ্রেডে চলে, তাই time.sleep(3) কল করলে ওই থ্রেডটি 3 সেকেন্ডের জন্য পুরোপুরি ব্লক হয়ে যায়। operating system 
অন্যান্য কাজ করলেও পাইথনের এই নির্দিষ্ট থ্রেডটি আর কোনো কাজ করতে পারে না। ফলে ইভেন্ট লুপ স্পিনার কোরুটিনটিকে চালানোর কোনো সুযোগ পায় না।

Note : asyncio কোরুটিনের ভেতর কখনো time.sleep(...) ব্যবহার করা উচিত নয় যদি না পুরো প্রোগ্রামটিকে থামিয়ে দেওয়ার উদ্দেশ্য থাকে। সময় কাটানোর 
জন্য সর্বদা await asyncio.sleep(DELAY) ব্যবহার করা উচিত যা ইভেন্ট লুপকে নিয়ন্ত্রণ ফিরিয়ে দেয়।
"""

"""
কোরুটিন নিয়ে আলোচনার ক্ষেত্রে greenlet প্যাকেজটির নাম উল্লেখ করা জরুরি। এটি দীর্ঘদিন ধরে বড় পরিসরে ব্যবহৃত হয়ে আসছে।

1. Greenlet: এটি কো-অপারেটিভ মাল্টিটাস্কিং সমর্থন করে। এর জন্য yield বা await এর মতো বিশেষ সিনট্যাক্সের প্রয়োজন হয় না। তাই বিদ্যমান সাধারণ 
কোডের সাথে এটি সহজে ব্যবহার করা যায়। SQLAlchemy ১.৪ এর ওআরএম (ORM) এটি ব্যবহার করে।

2. gevent: এটি একটি নেটওয়ার্কিং লাইব্রেরি যা পাইথনের স্ট্যান্ডার্ড সকেট মডিউলকে 'মাঙ্কি প্যাচ' (monkey patch) করে নন-ব্লকিং করে তোলে। এটি সাধারণ 
সিকুয়েন্সিয়াল অ্যাপ্লিকেশন এবং ডেটাবেস ড্রাইভারগুলোকে কনকারেন্ট নেটওয়ার্ক আইও করার উপযোগী করে তোলে। Gunicorn এর মতো জনপ্রিয় প্রজেক্টে এটি ব্যবহৃত হয়।
"""
