Threading কোডের ক্ষেত্রে কোনো ফাংশনের ভেতরে time.sleep(3)-এর পরিবর্তে যদি কোনো উন্নত network library ব্যবহার করে HTTP রিকোয়েস্ট পাঠানো হয়
তবে দেখা যাবে spinner-টি ঠিকঠাক ঘুরছে। এর কারণ হলো একটি well-designed নেটওয়ার্ক লাইব্রেরি যখন নেটওয়ার্ক রেসপন্সের জন্য অপেক্ষা করে, তখন সেটি
GIL ছেড়ে দেয়। ফলে অন্য থ্রেড কাজ করার সুযোগ পায়।

একইভাবে asyncio-এর ক্ষেত্রে await asyncio.sleep(3)-এর বদলে যদি কোনো asynchronous network library ব্যবহার করা হয়, তবে সেটি event
লুপের কাছে control ফিরিয়ে দেয়। ফলে spinner-টি সচল থাকে।

কিন্তু CPU-intensive বা প্রসেসর-নির্ভর কাজের ক্ষেত্রে চিত্রটি ভিন্ন। নিচে একটি prime number check করার function is_prime দেওয়া হলো:

import math

def is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False

    root = math.isqrt(n)
    for i in range(3, root + 1, 2):
        if n % i == 0:
            return False
    return True

একটি বড় সংখ্যা (যেমন: 5000111000222021) এই ফাংশনে ইনপুট দিলে সেটি প্রসেস করতে সাধারণ ল্যাপটপে প্রায় ৩.৩ সেকেন্ড সময় লাগে।

যদি একটি স্পিনার অ্যানিমেশন চলাকালীন ওপরের is_prime ফাংশনটি কল করা হয়, তবে তিনটি ভিন্ন পদ্ধতিতে কী ঘটবে তা নিচে বিশ্লেষণ করা হলো:

1. In spinner_proc.py, replace time.sleep(3) with a call to is_prime(n)? (coding file -> spinner_with_processes.py)
-> Multiprocessing system-এ spinner-টি একটি আলাদা child process দ্বারা নিয়ন্ত্রিত হয়। তাই Main process যখন heavy cpu intensive(গাণিতিক হিসাব
বা primality test) task execute করে, তখন স্পিনারটি কোনো বাধা ছাড়াই ঘুরতে থাকে। কারণ দুটি কাজ সম্পূর্ণ আলাদা দুটি প্রসেসরে বা প্রসেসে চলে।


2. In spinner_thread.py, replace time.sleep(3) with a call to is_prime(n)? (coding file -> spinner_with_threads.py)
-> এখানে একটি secondary thread spinner-টিকে নিয়ন্ত্রণ করে এবং main thread is_prime ফাংশনটি চালায়। সাধারণত মনে হতে পারে যে GIL-এর
কারণে spinner-টি আটকে যাবে, কিন্তু বাস্তবে thread-টি ঘুরতে থাকবে। এর কারণ হলো python ডিফল্টভাবে প্রতি ৫ millisecond অন্তর অন্তর চলমান
thread-টিকে সাময়িকভাবে থামিয়ে দেয় (suspend)। একে `check interval` বলা হয়। এই বিরতির ফলে GIL অন্য থ্রেডগুলোর জন্য উন্মুক্ত হয়। ফলে :
    - main thread যখন is_prime ফাংশনের calculation করতে থাকে, তখন সেটি প্রতি ৫ মিলিসেকেন্ড পরপর বাধাগ্রস্ত হয়।
    - এই বিরতির সুযোগে secondary thread-টি active হয় এবং লুপের ভেতর একবার ঘুরে স্পিনারটিকে আপডেট করে।
    - এরপর যখন এটি ইভেন্টের wait মেথড কল করে, তখন এটি পুনরায় GIL ছেড়ে দেয়।
    - তখন main thread-টি আবারও GIL দখল করে এবং পরবর্তী ৫ মিলিসেকেন্ডের জন্য হিসাব চালিয়ে যায়।

main thread থেকে GIL উন্মুক্ত হলে যদিও main thread-টি CPU দখল করে রাখে তবুও প্রতি ৫ millisecond পরপর সেকেন্ডারি thread-টি একবার লুপ চালানোর
সুযোগ পায় এবং স্পিনারটি আপডেট করে আবার অপেক্ষায় চলে যায়। যেহেতু স্পিনার আপডেট করতে খুব কম সময় লাগে, তাই মেইন থ্রেডটিই বেশিরভাগ সময় GIL নিজের
কাছে রাখতে পারে এবং calculation চালিয়ে যেতে পারে।

এই প্রক্রিয়ায় পুরো প্রোগ্রামটি শেষ হতে যে সময় লাগে তার ওপর কোনো দৃশ্যমান প্রভাব পড়ে না। কারণ স্পিনার ফাংশনটি খুব দ্রুত একবার লুপ ঘুরিয়েই GIL ছেড়ে দেয় এবং
ইভেন্টের জন্য অপেক্ষা করতে থাকে। ফলে এখানে GIL দখল করা নিয়ে থ্রেডগুলোর মধ্যে তেমন কোনো কাড়াকাড়ি বা প্রতিযোগিতা (contention) হয় না। বেশিরভাগ সময়
মেইন থ্রেডটিই GIL নিজের কাছে রাখতে পারে এবং হিসাব চালিয়ে যেতে পারে।

এই পরীক্ষায় থ্রেডিং ব্যবহার করে একটি CPU-intensive কাজ সফলভাবে করা সম্ভব হয়েছে কারণ এখানে মাত্র দুটি থ্রেড ছিল: একটি যা পুরো CPU দখল করে রাখছিল
এবং অন্যটি যা সেকেন্ডে মাত্র ১০ বার active হয়ে স্পিনার update করছিল।


3. In spinner_async.py, replace await asyncio.sleep(3) with a call to is_prime(n)? (coding file -> spinner_with_coroutines.py)
-> যদি asyncio ব্যবহার করে is_prime ফাংশনটি কল করা হয়, তবে স্পিনারটি একেবারেই দেখা যাবে না। পুরো প্রোগ্রামটি ৩ সেকেন্ডের জন্য freeze হয়ে
যাবে এবং তারপর সরাসরি answer দেখাবে। এর কারণ হলো asyncio একটি একক থ্রেডে ইভেন্ট লুপের মাধ্যমে কাজ করে। এটি cooperative multitasking
নীতিতে চলে। যেহেতু is_prime একটি সাধারণ ফাংশন এবং এটি নিজে থেকে ইভেন্ট লুপের কাছে নিয়ন্ত্রণ ফিরিয়ে দেয় না, তাই এটি পুরো ইভেন্ট লুপকে ব্লক
করে রাখে। যতক্ষণ না calculation শেষ হচ্ছে, ততক্ষণ event loop অন্য কোনো কাজ (যেমন স্পিনার চালানো) করতে পারে না।


# Power Napping এবং sleep(0) (coding file -> make_is_prime_as_coroutine.py)
অ্যাসিনক্রোনাস কোডে স্পিনারটিকে সচল রাখার একটি উপায় হলো is_prime ফাংশনটিকে একটি কোরুটিন (coroutine) হিসেবে লেখা এবং মাঝেমধ্যে await
asyncio.sleep(0) ব্যবহার করা।

async def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False

    root = math.isqrt(n)
    for i in range(3, root + 1, 2):
        if n % i == 0:
            return False

        # প্রতি 50000 বার লুপ ঘোরার পর ইভেন্ট লুপকে সুযোগ দেওয়া
        if i % 100000 == 1:
            await asyncio.sleep(0)

    return True

এখানে await asyncio.sleep(0) কল করার মাধ্যমে ইভেন্ট লুপকে অন্য কাজ করার সামান্য সুযোগ দেওয়া হয়। এতে স্পিনারটি Smoothly ঘোরে। তবে
এর একটি বড় অসুবিধা আছে:
  - এটি প্রোগ্রামের গতি কমিয়ে দেয়। উদাহরণস্বরূপ, যে হিসাব ৩.৩ সেকেন্ডে হওয়ার কথা, তা ৪.৯ সেকেন্ড পর্যন্ত সময় নিতে পারে (প্রায় ৫০% বেশি সময়)।
  - এটি পুরো ইভেন্ট লুপের কার্যক্ষমতাকে ধীর করে দেয়।

তাই await asyncio.sleep(0) ব্যবহার করাকে একটি অস্থায়ী সমাধান হিসেবে বিবেচনা করা হয়। দীর্ঘ ও জটিল CPU-নির্ভর কাজের জন্য
asyncio.loop.run_in_executor ব্যবহার করে কাজটিকে অন্য প্রসেসে পাঠিয়ে দেওয়াই সঠিক পদ্ধতি।
