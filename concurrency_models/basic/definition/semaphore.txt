Semaphore হলো একটি Signaling Mechanism যা মাল্টি-প্রসেসিং এনভায়রনমেন্টে বিভিন্ন প্রসেসের মধ্যে সমন্বয় (Synchronization) বজায় রাখতে
ব্যবহৃত হয়।

locking মেকানিজম (like-Mutex) কাজ করে Ownership-এর ভিত্তিতে। অর্থাৎ যে প্রসেসটি কোনো রিসোর্স লক করবে কাজ শেষে তাকেই সেই লক খুলতে হবে।
কিন্তু Semaphore কাজ করে Signal-এর ভিত্তিতে। এখানে কোনো নির্দিষ্ট Ownership নেই। একটি প্রসেস সিগন্যালের জন্য অপেক্ষা করতে পারে (Wait)
আর অন্য একটি প্রসেস Signal দিতে পারে যে রিসোর্সটি এখন খালি।

Semaphore একটি "ডিজিটাল টোকেন কাউন্টার" মতো। like একটি পার্কে মাত্র ৩টি দোলনা আছে। এখন অনেক মানুষ (প্রসেস বা থ্রেড) সেই দোলনা
ব্যবহার করতে চায়। পার্কের গেটে একজন গার্ড একটি বোর্ডে লিখে রাখলেন "৩"।

- যখন একজন মানুষ দোলনায় বসবে, গার্ড বোর্ড থেকে ১ কমিয়ে "২" করে দেবেন।
- যখন ৩ জনই বসে যাবে, বোর্ডের মান হবে "০"। এখন নতুন কেউ আসলে তাকে অপেক্ষা করতে হবে।
- যখন কেউ দোলনা ছেড়ে চলে যাবে, গার্ড মান ১ বাড়িয়ে দেবেন। তখন লাইনে থাকা পরবর্তী ব্যক্তি সুযোগ পাবে।

এই যে গার্ড যে সংখ্যাটি (Variable) নিয়ন্ত্রণ করছেন, এটাই হলো Semaphore।


-> Semaphore প্রধানত দুই প্রকারের হয়:
1. Binary Semaphore:
- এর মান শুধুমাত্র ০ অথবা ১ হতে পারে।
- এটি অনেকটা Lock/Unlock মতো কাজ করে। এটি মূলত Mutex এর মতো কাজ করে যেখানে একবারে মাত্র একজনই রিসোর্স ব্যবহার করতে পারে।

2. Counting Semaphore:
- এর মান যেকোনো পজিটিভ পূর্ণসংখ্যা হতে পারে।
- যখন আমাদের কাছে একাধিক একই ধরণের রিসোর্স থাকে (যেমন: ৫টি প্রিন্টার), তখন এটি ব্যবহৃত হয়।


-> Main Mechanism
Semaphore প্রধানত দুটি অপারেশন ব্যবহার করে কোনো প্রসেসকে অনুমতি দেয় বা আটকে রাখে। 

1. Wait Operation (P বা Sleep): যখন কোনো প্রসেস একটি রিসোর্স (যেমন: ফাইল বা ডেটাবেস) ব্যবহার করতে চায়, তখন সে wait কল 
করে। 
এর লজিক হলো: যদি সেমাফোরের মান 0-এর চেয়ে বেশি হয়, তবে এটি মান ১ কমিয়ে দেয় এবং প্রসেসটিকে রিসোর্স ব্যবহারের অনুমতি দেয়। যদি মান 0 
হয়, তবে প্রসেসটিকে অপেক্ষা করতে হয় যতক্ষণ না অন্য কেউ রিসোর্সটি ছেড়ে দেয়।

গাণিতিকভাবে :
        wait(S) {
           while (S > 0):
                S = S - 1;
        }

2. Signal Operation (V বা Wakeup): যখন কোনো প্রসেসের কাজ শেষ হয়ে যায়, তখন সে signal কল করে রিসোর্সটি ছেড়ে দেয়।
এর লজিক হলো: এটি সেমাফোরের মান ১ বাড়িয়ে দেয়। মান বাড়ার সাথে সাথে অপেক্ষারত অন্য কোনো প্রসেস কাজ শুরু করার সংকেত পায়।
গাণিতিকভাবে:
            signal(S) {
                S = S + 1
            }

-> কাজের ধাপগুলো (Step-by-step Flow) : ধরা যাক, একটি সিস্টেমে একটি Semaphore আছে যার প্রাথমিক মান S = 1 (বাইনারি সেমাফোর)।
1. প্রবেশের অনুরোধ: Process-A এসে wait(S) call করল। যেহেতু S=1, তাই সে মান কমিয়ে S=0 করল এবং ভেতরে ঢুকে কাজ শুরু করল।

2. বাধা দান: এই অবস্থায় Process-B এসে একই রিসোর্স ব্যবহার করতে চাইলে সে দেখবে S=0। ফলে সে ভেতরে ঢুকতে পারবে না এবং Waiting
State-এ থাকবে।

3. Release বা মুক্তি: Process-A এর কাজ শেষ হলে সে signal(S) call করল। ফলে সেমাফোরের মান আবার বেড়ে S=1 হলো।

4. পরের প্রসেসের সুযোগ: সাথে সাথে Process-B জানতে পারল যে resource এখন ফাঁকা। সে তখন দ্রুত S=0 করে নিজের কাজ শুরু করল।

সেমাফোরের এই অপারেশনগুলো Atomic বা অবিভাজ্য। এর মানে হলো, যখন একটি process সেমাফোরের মান পরিবর্তন করছে, তখন অন্য কোনো
process মাঝপথে এসে সেই মান পরিবর্তন করতে পারবে না। এটি Hardware লেভেলে নিশ্চিত করা হয় যাতে কোনো বিশৃঙ্খলা না ঘটে।
