"""
Q: Concurrency কী?
-> কনকারেন্সি মানে হলো যখন একটি প্রোগ্রাম একই সময়ে একাধিক কাজ পরিচালনা করে। এখানে Main Thread একটি heavy calculation করছে আর অন্য
একটি Thread (Side Thread) স্ক্রিনে loading এনিমেশন দেখাচ্ছে যাতে ব্যবহারকারী বুঝতে পারে প্রোগ্রামটি সচল আছে।
"""


import itertools
import time
from threading import Thread, Event

def spin(msg: str, done: Event):
    for char in itertools.cycle(r'\|/-'):
        status = f'\r{char} {msg}'
        print(status, end='', flush=True)

        if done.wait(0.1):
            break
    blanks = ' ' * len(status)
    print(f'\r{blanks}\r', end='')


def slow():
    time.sleep(3)
    return 42

def supervisor():
    done = Event()

    spinner = Thread(target=spin, args=('thinking!', done))
    print(f'Spinner Object: {spinner}')

    spinner.start()

    result = slow()

    done.set()

    spinner.join()

    return result

def main():
    result = supervisor()
    print(f"Answer : {result}")

if __name__ == '__main__':
    main()


"""
1. spin(msg, done) function: এই ফাংশনটি একটি আলাদা থ্রেডে চলবে। এখানে done হলো একটি threading.Event অবজেক্ট। এটি অনেকটা ট্রাফিক 
সিগন্যালের মতো কাজ করে, যা এক থ্রেড থেকে অন্য থ্রেডে সংকেত পাঠাতে ব্যবহৃত হয়।

2. itertools.cycle এর লুপ: এনিমেশন তৈরির জন্য \|/- এই চারটি character-কে বারবার চক্রাকারে ঘোরানো প্রয়োজন। cycle ফাংশনটি এই কাজটিকে 
সহজ করে দেয়, যা সারাক্ষণ এই character গুলো একের পর এক প্রদান করে।

3. Text mode Animation trick (\r): এখানে \r (Carriage Return) ব্যবহার করা হয়েছে। এটি কার্সারকে লাইনের একদম শুরুতে নিয়ে আসে। এর 
ফলে প্রতিবার নতুন লাইন তৈরি না হয়ে একই জায়গায় অক্ষরগুলো পরিবর্তিত হয়, যা একটি ঘূর্ণায়মান Animation তৈরি করে।

4. done.wait(.1) এর ভূমিকা: এটি প্রতি ০.১ সেকেন্ড পর পর চেক করে দেখে যে প্রধান থ্রেড থেকে কাজ শেষ হওয়ার কোনো সংকেত এসেছে কি না। যদি 
কোনো সংকেত না আসে তবে এটি ০.১ সেকেন্ড অপেক্ষা করে আবার এনিমেশন দেখায়। এই সময়টুকুই এনিমেশনের গতি নির্ধারণ করে।

5. loop থেকে বের হওয়া (break): যখন কাজ শেষ হয়ে যায় এবং done সংকেত পায়, তখন এই লুপটি বন্ধ হয়ে যায়।

6. Screen Clean করা: Animation শেষ হওয়ার পর সেই জায়গাটি খালি করার জন্য কিছু space প্রিন্ট করা হয় এবং কার্সার পুনরায় লাইনের শুরুতে নিয়ে 
আসা হয়। এতে Screen-টি দেখতে পরিষ্কার লাগে।

7. slow() ফাংশন: এটি একটি কৃত্রিম "heavy work" যা সম্পন্ন হতে ৩ সেকেন্ড সময় নেয়। time.sleep(3) ব্যবহার করার ফলে এই thread-টি ৩ 
সেকেন্ডের জন্য থেমে থাকে, কিন্তু পাইথনের GIL (Global Interpreter Lock) মুক্ত করে দেয়। ফলে প্রধান থ্রেড থেমে থাকলেও অন্য থ্রেডটি (Spinner) 
স্বাচ্ছন্দ্যে চলতে পারে।
"""

"""
1. r'\|/-' (Raw String)
এখানে r অক্ষরটির অর্থ হলো "Raw String"। সাধারণত পাইথনে ব্যাকস্ল্যাশ (\) একটি বিশেষ ক্যারেক্টার (যেমন \n মানে নতুন লাইন)। কিন্তু যদি স্ট্রিংয়ের 
আগে r লিখে দেওয়া হয়, তবে পাইথন ওই স্ট্রিংয়ের ভেতরের কোনো কিছুকেই বিশেষ কমান্ড হিসেবে ধরে নেয় না।
এখানে এনিমেশনের জন্য চারটি ক্যারেক্টার ব্যবহার করা হয়েছে: \, |, /, এবং -।
যেহেতু \ নিজেই পাইথনে একটি বিশেষ চিহ্ন, তাই এটি যাতে সাধারণ text হিসেবে কাজ করে, সেজন্য r ব্যবহার করা হয়েছে।

2. itertools.cycle(r'\|/-')
itertools.cycle হলো পাইথনের একটি ফাংশন যা কোনো তালিকার উপাদানগুলোকে অনন্তকাল ধরে Repeat করতে পারে। এটি \ এর পর |, তারপর / এবং 
সবশেষে - প্রদান করে। এরপর এটি আবার শুরু থেকে \ দিয়ে শুরু করে। এই cycle-টি চলতেই থাকে যতক্ষণ না প্রোগ্রামটি বন্ধ করা হয়। এভাবেই এনিমেশনের জন্য 
প্রয়োজনীয় অক্ষরগুলো বারবার পাওয়া যায়।

3. \r (Carriage Return)
এটি এনিমেশন তৈরির সবচেয়ে গুরুত্বপূর্ণ অংশ। সাধারণ print() ফাংশন টেক্সট প্রিন্ট করার পর কার্সারকে পরের লাইনে নিয়ে যায়। কিন্তু \r ব্যবহার করলে কার্সার 
নিচে না গিয়ে বর্তমান লাইনের একদম শুরুতে চলে আসে।

কাজ করার পদ্ধতি: ধরুন প্রথমে \ প্রিন্ট হলো। এরপর \r কার্সারকে লাইনের শুরুতে নিয়ে আসলো। এবার যখন পরবর্তী ক্যারেক্টার | প্রিন্ট হবে, সেটি আগের \ এর 
ওপরেই বসবে। এভাবে একই জায়গায় অক্ষরগুলো দ্রুত পরিবর্তিত হওয়ার কারণে স্ক্রিনে একটি ঘূর্ণায়মান এনিমেশন বা স্পিনার দেখা যায়।

4. done.wait(.1)
এই লাইনটি স্পিনার থ্রেডের ভেতরে দুটি গুরুত্বপূর্ণ কাজ একসাথে করে:
- টাইমার হিসেবে: এটি স্পিনারকে ০.১ সেকেন্ড অপেক্ষা করতে বাধ্য করে। এর ফলে এনিমেশনটি খুব বেশি দ্রুত হয় না এবং এটি সেকেন্ডে ১০ বার পরিবর্তিত 
হয় (Frame Rate)।

- সংকেত পরীক্ষা: এটি চেক করে দেখে যে done নামের ইভেন্টটি অন্য কোনো থ্রেড থেকে "Set" বা চালু করা হয়েছে কি না। যদি ০.১ সেকেন্ডের মধ্যে কোনো 
সংকেত না আসে, তবে এটি False রিটার্ন করে এবং লুপ চলতে থাকে। যদি অন্য থ্রেড থেকে কাজ শেষ হওয়ার সংকেত আসে, তবে এটি সাথে সাথে True 
রিটার্ন করে।

5. threading.Event হলো থ্রেডগুলোর মধ্যে যোগাযোগের একটি অত্যন্ত শক্তিশালী মাধ্যম। একে একটি "flag" সাথে তুলনা করা যায়।
- শুরুতে: যখন done = Event() তৈরি করা হয় তখন এর মান False।
- স্পিনার থ্রেডে: spin ফাংশনের ভেতরে if done.wait(.1): break লাইনটি সারাক্ষণ ওই flag দিকে তাকিয়ে থাকে। যতক্ষণ flag false করা থাকে 
স্পিনার ঘুরতে থাকে।
- মূল থ্রেডে: যখন slow() ফাংশনের কাজ (৩ সেকেন্ডের কাজ) শেষ হয়, তখন done.set() কল করা হয়। এর মানে হলো flag এর Value True করা হয়েছে
- সমাপ্তি: done.set() call করার সাথে সাথে স্পিনার থ্রেডটি তা বুঝতে পারে, লুপ থেকে বের হয়ে আসে (Break) এবং এনিমেশন বন্ধ করে দেয়।
"""